---
title: "Untitled"
author: "Adam Hettinger"
date: "1/15/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


```{r}
simulate_mrp_data <- function(n) {
  J <- c(2, 3, 7, 3, 50) # male or not, eth, age, income level, state
  poststrat <- as.data.frame(array(NA, c(prod(J), length(J)+1))) # Columns of post-strat matrix, plus one for size
  colnames(poststrat) <- c("male", "eth", "age","income", "state",'N')
  count <- 0
  for (i1 in 1:J[1]){
    for (i2 in 1:J[2]){
      for (i3 in 1:J[3]){
        for (i4 in 1:J[4]){
          for (i5 in 1:J[5]){
              count <- count + 1
              # Fill them in so we know what category we are referring to
              poststrat[count, 1:5] <- c(i1-1, i2, i3, i4, i5) 
          }
        }
      }
    }
  }
  # Proportion in each sample in the population
  p_male <- c(0.52, 0.48)
  p_eth <- c(0.5, 0.2, 0.3)
  p_age <- c(0.2,.1,0.2,0.2, 0.10, 0.1, 0.1)
  p_income<-c(.50,.35,.15)
  p_state_tmp<-runif(50,10,20)
  p_state<-p_state_tmp/sum(p_state_tmp)
  poststrat$N<-0
  for (j in 1:prod(J)){
    poststrat$N[j] <- round(250e6 * p_male[poststrat[j,1]+1] * p_eth[poststrat[j,2]] *
      p_age[poststrat[j,3]]*p_income[poststrat[j,4]]*p_state[poststrat[j,5]]) #Adjust the N to be the number observed in each category in each group
  }
  
  # Now let's adjust for the probability of response
  p_response_baseline <- 0.01
  p_response_male <- c(2, 0.8) / 2.8
  p_response_eth <- c(1, 1.2, 2.5) / 4.7
  p_response_age <- c(1, 0.4, 1, 1.5,  3, 5, 7) / 18.9
  p_response_inc <- c(1, 0.9, 0.8) / 2.7
  p_response_state <- rbeta(50, 1, 1)
  p_response_state <- p_response_state / sum(p_response_state)
  p_response <- rep(NA, prod(J))
  for (j in 1:prod(J)) {
    p_response[j] <-
      p_response_baseline * p_response_male[poststrat[j, 1] + 1] *
      p_response_eth[poststrat[j, 2]] * p_response_age[poststrat[j, 3]] *
      p_response_inc[poststrat[j, 4]] * p_response_state[poststrat[j, 5]]
  }
  people <- sample(prod(J), n, replace = TRUE, prob = poststrat$N * p_response)
  
  ## For respondent i, people[i] is that person's poststrat cell,
  ## some number between 1 and 32
  n_cell <- rep(NA, prod(J))
  for (j in 1:prod(J)) {
    n_cell[j] <- sum(people == j)
  }
  
  coef_male <- c(0,-0.3)
  coef_eth <- c(0, 0.6, 0.9)
  coef_age <- c(0,-0.2,-0.3, 0.4, 0.5, 0.7, 0.8, 0.9)
  coef_income <- c(0,-0.2, 0.6)
  coef_state <- c(0, round(rnorm(49, 0, 1), 1))
  coef_age_male <- t(cbind(c(0, .1, .23, .3, .43, .5, .6),
                           c(0, -.1, -.23, -.5, -.43, -.5, -.6)))
  true_popn <- data.frame(poststrat[, 1:5], cat_pref = rep(NA, prod(J)))
  for (j in 1:prod(J)) {
    true_popn$cat_pref[j] <- plogis(
      coef_male[poststrat[j, 1] + 1] +
        coef_eth[poststrat[j, 2]] + coef_age[poststrat[j, 3]] +
        coef_income[poststrat[j, 4]] + coef_state[poststrat[j, 5]] +
        coef_age_male[poststrat[j, 1] + 1, poststrat[j, 3]]
      )
  }
  
  #male or not, eth, age, income level, state, city
  y <- rbinom(n, 1, true_popn$cat_pref[people])
  male <- poststrat[people, 1]
  eth <- poststrat[people, 2]
  age <- poststrat[people, 3]
  income <- poststrat[people, 4]
  state <- poststrat[people, 5]
  
  sample <- data.frame(cat_pref = y, 
                       male, age, eth, income, state, 
                       id = 1:length(people))
  
  #Make all numeric:
  for (i in 1:ncol(poststrat)) {
    poststrat[, i] <- as.numeric(poststrat[, i])
  }
  for (i in 1:ncol(true_popn)) {
    true_popn[, i] <- as.numeric(true_popn[, i])
  }
  for (i in 1:ncol(sample)) {
    sample[, i] <- as.numeric(sample[, i])
  }
  list(
    sample = sample,
    poststrat = poststrat,
    true_popn = true_popn
  )
}


mrp_sim <- simulate_mrp_data(n=100)
str(mrp_sim)
sample <- mrp_sim[["sample"]]

poststrat <- mrp_sim[["poststrat"]]
true_popn <- mrp_sim[["true_popn"]]


sample2 = sample %>% 
  select(cat_pref, male, age, eth, income, state)
```




```{}

data{
    int g[700];
    vector[700] intent;
    vector[700] price;
    int brand[700];
}
parameters{
    vector[5] alpha;
    real beta;
    real<lower=0,upper=3> sigma;
}
model{
    vector[700] mu;
    sigma ~ uniform( 0 , 3 );
    beta ~ normal( 0.2 , 0.1 );
    alpha ~ normal( 0.2 , 0.1 );
    for ( i in 1:700 ) {
        mu[i] = alpha[brand[i]] + beta * price[i];
    }
    intent ~ normal( mu , sigma );
}

```



```{}
# Observation model.
intent_n ∼ Normal(mu_n, sigma)
mu_n = alpha[g[n],] * brand_n + beta[g[n]] * price_n

# Population model.
alpha ∼ Normal(gamma, tau), for k = 1:3 and i = 1:5
beta ~ Normal(gamma, tau), for k = 1:3

# Hyperpriors and prior.
gamma ∼ Normal(0.2, 0.1)
tau ~ Uniform(0, 3)
sigma ∼ Uniform(0, 3)



# Observation model.
intent_n ∼ Normal(mu_n, sigma)
mu_n = alpha[male[n],] * eth_n + beta[male[n]] * income_n

# Population model.
alpha ∼ Normal(gamma, tau), for k = 1:2 and i = 1:5
beta ~ Normal(gamma, tau), for k = 1:2

# Hyperpriors and prior.
gamma ∼ Normal(0.2, 0.1)
tau ~ Uniform(0, 3)
sigma ∼ Uniform(0, 3)


```


```{r}
# Specify values to simulate data.
library(tidyverse)
library(rethinking)
library(rstan)
library(bayesplot)
library(tidybayes)

load(here::here("purchase_intent.RData"))


sim_values <- list(
  N = 6300,                                       # Number of observations.
  K = 2,                                         # Number of groups.
  I = 65,                                         # Number of observation-level covariates.
  
  male = sample(2, 6300, replace = TRUE),            # Vector of group assignments.
  eth = sample(3, 6300, replace = TRUE),       # Vector of brands covariates.
  age = sample(7, 6300, replace = TRUE),        # Vector of price covariates.
  income = sample(3, 6300, replace = TRUE),
  state = sample(50, 6300, replace = TRUE),
  
  gamma_mean = 0.5,                              # Mean for the hyperprior on gamma.
  gamma_var = 0.2,                               # Variance for the hyperprior on gamma.
  tau_min = 0,                                   # Minimum for the hyperprior on tau.
  tau_max = .1,                                   # Maximum for the hyperprior on tau.
  sigma_min = 0,                                 # Minimum for the hyperprior on tau.
  sigma_max = .1                                  # Maximum for the hyperprior on tau.
)

# Generate data.
sim_data <- stan(
  file = here::here("generate_data.stan"),
  data = sim_values,
  iter = 10,
  chains = 1,
  seed = 42,
  algorithm = "Fixed_param"
)
```



```{r}
# Extract the simulated data.
prior_pc <- tibble(
  cat_pref = as.vector(extract(sim_data)$cat_pref)
)

# Plot the prior predictive distribution.
prior_pc %>% 
  ggplot(aes(x = cat_pref)) +
  geom_density()
```

```{r}
# Specify data.
data <- list(
  N = nrow(true_popn),                     # Number of observations.
  K = 2,                    # Number of groups.
  I = 65,                                # Number of observation-level covariates.
  
  cat_pref = true_popn$cat_pref,               # Vector of observations.
  male = as.numeric(as.factor(true_popn$male)),            # Vector of group assignments.
  eth = true_popn$eth,       # Vector of brands covariates.
  age = true_popn$age,        # Vector of price covariates.
  income = true_popn$income,
  state = true_popn$state,
  
  gamma_mean = 0.5,                                # Mean for the hyperprior on gamma.
  gamma_var = .2,                                 # Variance for the hyperprior on gamma.
  tau_min = 0,                                   # Minimum for the hyperprior on tau.
  tau_max = 1,                                   # Maximum for the hyperprior on tau.
  sigma_min = 0,                                 # Minimum for the hyperprior on tau.
  sigma_max = 1                                 # Maximum for the hyperprior on tau.
)

# Calibrate the model.
model03 <- stan(
  file = here::here("hierarchical_model.stan"),
  data = data,
  control = list(adapt_delta = 0.99),
  seed = 42
)
```



```{r}
# Posterior predictive check.
post_pc03 <- tibble(
  # Extract the posterior predicted values.
  intent = as.vector(extract(model03)$cat_pref_pc)
)

# Plot the posterior predictive distribution.
ggplot(post_pc03, aes(x = intent)) +
  geom_histogram() +
  xlim(1, 10) 

ggplot(purchase_intent, aes(x = intent)) +
  geom_histogram() +
  xlim(1, 10) 
```


```{r}
model03 %>%
  gather_draws(alpha[n, i]) %>%
  unite(.variable, .variable, n, i) %>%
  ggplot(aes(x = .value, y = .variable)) +
  geom_halfeyeh(.width = .95) +
  facet_wrap(
    ~ .variable,
    nrow = data$K,
    ncol = (data$I - 1),
    scales = "free"
  )
```


```{r}
# Plot the betas.
model03 %>%
  gather_draws(beta[i]) %>%
  unite(.variable, .variable, i) %>%
  ggplot(aes(x = .value, y = .variable)) +
  geom_halfeyeh(.width = .95) +
  facet_wrap(
    ~ .variable,
    nrow = data$K,
    ncol = 1,
    scales = "free"
  )
```

